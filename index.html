<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <title>盒子走位躲避小游戏</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #111;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #gameCanvas {
        display: block;
        margin: 0 auto;
        background: #000;
        border: 2px solid #333;
        touch-action: none;
        /* 让canvas有阴影更突出 */
        box-shadow: 0 4px 24px #000a;
      }
      #scoreLabel {
        position: absolute;
        left: 10px;
        top: 10px;
        color: #fff;
        font-size: 18px;
        font-family: 微软雅黑, sans-serif;
        z-index: 10;
        text-shadow: 1px 1px 2px #000;
      }
      #restartBtn {
        display: none;
        position: absolute;
        left: 50%;
        top: 60%;
        transform: translate(-50%, -50%);
        font-size: 20px;
        padding: 10px 30px;
        border-radius: 8px;
        border: none;
        background: #222;
        color: #fff;
        box-shadow: 0 2px 8px #0008;
        cursor: pointer;
      }
      /* 虚拟摇杆优化：更大更居中 */
      #joystick {
        position: fixed;
        left: 50%;
        bottom: 7vw;
        transform: translateX(-50%);
        width: 48vw;
        height: 48vw;
        min-width: 160px;
        min-height: 160px;
        max-width: 340px;
        max-height: 340px;
        z-index: 20;
        display: none;
        pointer-events: auto;
      }
      #joystick-base {
        width: 100%;
        height: 100%;
        background: #444b;
        border-radius: 50%;
        position: absolute;
        left: 0;
        top: 0;
      }
      #joystick-stick {
        width: 44%;
        height: 44%;
        background: #fff9;
        border-radius: 50%;
        position: absolute;
        left: 28%;
        top: 28%;
        box-shadow: 0 2px 12px #000a;
        touch-action: none;
        transition: left 0.08s, top 0.08s;
      }
      @media (max-width: 700px) {
        #gameCanvas {
          width: 98vw;
          height: 70vw;
          max-width: 100vw;
          max-height: 80vh;
        }
        #joystick {
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <div id="scoreLabel">得分: 0</div>
    <canvas id="gameCanvas" width="500" height="400"></canvas>
    <button id="restartBtn">重新开始</button>
    <div id="joystick">
      <div id="joystick-base"></div>
      <div id="joystick-stick"></div>
    </div>
    <script>
      const WIDTH = 500,
        HEIGHT = 400,
        PLAYER_SIZE = 20,
        BALL_SIZE = 16,
        BALL_SPEED = 4,
        BALL_INTERVAL = 900;
      let canvas = document.getElementById("gameCanvas");
      let ctx = canvas.getContext("2d");
      let scoreLabel = document.getElementById("scoreLabel");
      let restartBtn = document.getElementById("restartBtn");
      let joystick = document.getElementById("joystick");
      let stick = document.getElementById("joystick-stick");
      let isMobile = /mobile|android|iphone|ipad|phone/i.test(
        navigator.userAgent
      );

      // 适配移动端canvas尺寸
      function resizeCanvas() {
        if (window.innerWidth < 700) {
          let w = Math.min(window.innerWidth * 0.98, 700);
          let h = (w * HEIGHT) / WIDTH;
          canvas.width = w;
          canvas.height = h;
        } else {
          canvas.width = WIDTH;
          canvas.height = HEIGHT;
        }
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // 游戏对象
      class Player {
        constructor() {
          this.x = canvas.width / 2;
          this.y = canvas.height / 2;
          this.size = (PLAYER_SIZE * canvas.width) / WIDTH;
        }
        move(dx, dy) {
          let nx = this.x + dx,
            ny = this.y + dy;
          let s = this.size / 2;
          if (
            s <= nx &&
            nx <= canvas.width - s &&
            s <= ny &&
            ny <= canvas.height - s
          ) {
            this.x = nx;
            this.y = ny;
          }
        }
        draw() {
          ctx.fillStyle = "#00bfff";
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(
            this.x - this.size / 2,
            this.y - this.size / 2,
            this.size,
            this.size
          );
          ctx.fill();
          ctx.stroke();
        }
      }
      class Ball {
        constructor(direction, vx, vy, x, y, color) {
          this.size = (BALL_SIZE * canvas.width) / WIDTH;
          this.color = color || Ball.randomColor();
          if (
            x !== undefined &&
            y !== undefined &&
            vx !== undefined &&
            vy !== undefined
          ) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
          } else {
            if (direction === "left") {
              this.x = 0;
              this.y =
                Math.random() * (canvas.height - this.size) + this.size / 2;
              this.vx = BALL_SPEED;
              this.vy = 0;
            } else if (direction === "right") {
              this.x = canvas.width;
              this.y =
                Math.random() * (canvas.height - this.size) + this.size / 2;
              this.vx = -BALL_SPEED;
              this.vy = 0;
            } else if (direction === "top") {
              this.x =
                Math.random() * (canvas.width - this.size) + this.size / 2;
              this.y = 0;
              this.vx = 0;
              this.vy = BALL_SPEED;
            } else {
              this.x =
                Math.random() * (canvas.width - this.size) + this.size / 2;
              this.y = canvas.height;
              this.vx = 0;
              this.vy = -BALL_SPEED;
            }
          }
          // 速度自适应缩放
          let scale = canvas.width / WIDTH;
          this.vx *= scale;
          this.vy *= scale;
        }
        static randomColor() {
          let arr = [
            "red",
            "orange",
            "yellow",
            "lime",
            "cyan",
            "blue",
            "magenta",
          ];
          return arr[Math.floor(Math.random() * arr.length)];
        }
        move() {
          this.x += this.vx;
          this.y += this.vy;
        }
        draw() {
          ctx.fillStyle = this.color;
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size / 2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
        }
        isOut() {
          return (
            this.x < -this.size ||
            this.x > canvas.width + this.size ||
            this.y < -this.size ||
            this.y > canvas.height + this.size
          );
        }
        collide(px, py, psize) {
          return (
            Math.abs(this.x - px) < (this.size + psize) / 2 &&
            Math.abs(this.y - py) < (this.size + psize) / 2
          );
        }
      }

      let player, balls, score, running, moveDir, lastBallTime;
      function resetGame() {
        player = new Player();
        balls = [];
        score = 0;
        running = true;
        moveDir = {
          left: 0,
          right: 0,
          up: 0,
          down: 0,
          _amp: 0,
          _vx: 0,
          _vy: 0,
        };
        lastBallTime = Date.now();
        restartBtn.style.display = "none";
        scoreLabel.textContent = "得分: 0";
        // 复活时摇杆stick回中心，重新计算中心和半径
        if (isMobile) {
          setTimeout(() => {
            updateJoystickCenter();
            stick.style.left = "28%";
            stick.style.top = "28%";
            moveDir.left = moveDir.right = moveDir.up = moveDir.down = 0;
            moveDir._amp = 0;
            moveDir._vx = 0;
            moveDir._vy = 0;
          }, 50);
        }
      }
      resetGame();

      function spawnBall() {
        if (!running) return;
        let r = Math.random();
        if (r < 0.5) {
          let dir = ["left", "right", "top", "bottom"][
            Math.floor(Math.random() * 4)
          ];
          balls.push(new Ball(dir));
        } else {
          // 瞄准玩家
          let edge = ["left", "right", "top", "bottom"][
            Math.floor(Math.random() * 4)
          ];
          let x, y;
          if (edge === "left") {
            x = 0;
            y = Math.random() * canvas.height;
          } else if (edge === "right") {
            x = canvas.width;
            y = Math.random() * canvas.height;
          } else if (edge === "top") {
            x = Math.random() * canvas.width;
            y = 0;
          } else {
            x = Math.random() * canvas.width;
            y = canvas.height;
          }
          let dx = player.x - x,
            dy = player.y - y;
          let dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1e-6);
          let vx = ((BALL_SPEED * dx) / dist) * (canvas.width / WIDTH);
          let vy = ((BALL_SPEED * dy) / dist) * (canvas.width / WIDTH);
          balls.push(new Ball("custom", vx, vy, x, y));
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        player.draw();
        balls.forEach((b) => b.draw());
        if (!running) {
          ctx.save();
          ctx.textAlign = "center";
          ctx.font = `bold ${Math.floor(canvas.height / 10)}px 微软雅黑,Arial`;
          ctx.fillStyle = "#fff";
          ctx.fillText("游戏结束", canvas.width / 2, canvas.height / 2 - 20);
          ctx.font = `${Math.floor(canvas.height / 18)}px 微软雅黑,Arial`;
          ctx.fillStyle = "yellow";
          ctx.fillText(
            "最终得分: " + Math.floor(score / 10),
            canvas.width / 2,
            canvas.height / 2 + 20
          );
          ctx.font = `${Math.floor(canvas.height / 22)}px 微软雅黑,Arial`;
          ctx.fillStyle = "#ccc";
          ctx.fillText(
            "按R键或按钮重新开始",
            canvas.width / 2,
            canvas.height / 2 + 50
          );
          ctx.restore();
        }
      }

      function update() {
        if (
          !joyActive &&
          (stick.style.left !== "28%" || stick.style.top !== "28%")
        ) {
          stick.style.left = "28%";
          stick.style.top = "28%";
        }
        if (running) {
          // 移动
          let baseSpeed = 2.6 * (canvas.width / WIDTH); // 固定最大速度
          let dx, dy;
          if (isMobile && moveDir._amp) {
            // 只取方向，速度恒定最大值
            dx = moveDir._vx * baseSpeed;
            dy = moveDir._vy * baseSpeed;
            player.move(dx, dy);
          } else {
            dx = (moveDir.right ? 1 : 0) - (moveDir.left ? 1 : 0);
            dy = (moveDir.down ? 1 : 0) - (moveDir.up ? 1 : 0);
            if (dx || dy) {
              let len = Math.sqrt(dx * dx + dy * dy) || 1;
              player.move((dx * baseSpeed) / len, (dy * baseSpeed) / len);
            }
          }
          // 小球
          balls.forEach((b) => b.move());
          balls = balls.filter((b) => !b.isOut());
          // 碰撞
          for (let b of balls) {
            if (b.collide(player.x, player.y, player.size)) {
              running = false;
              restartBtn.style.display = "block";
              break;
            }
          }
          // 得分
          score++;
          scoreLabel.textContent = "得分: " + Math.floor(score / 10);
          // 发射小球
          if (Date.now() - lastBallTime > BALL_INTERVAL) {
            spawnBall();
            lastBallTime = Date.now();
          }
        }
        draw();
        requestAnimationFrame(update);
      }
      update();

      // 键盘控制
      window.addEventListener("keydown", (e) => {
        if (!running && (e.key === "r" || e.key === "R")) {
          resetGame();
        }
        if (!running) return;
        if (["ArrowLeft", "a", "A"].includes(e.key)) moveDir.left = 1;
        if (["ArrowRight", "d", "D"].includes(e.key)) moveDir.right = 1;
        if (["ArrowUp", "w", "W"].includes(e.key)) moveDir.up = 1;
        if (["ArrowDown", "s", "S"].includes(e.key)) moveDir.down = 1;
      });
      window.addEventListener("keyup", (e) => {
        if (["ArrowLeft", "a", "A"].includes(e.key)) moveDir.left = 0;
        if (["ArrowRight", "d", "D"].includes(e.key)) moveDir.right = 0;
        if (["ArrowUp", "w", "W"].includes(e.key)) moveDir.up = 0;
        if (["ArrowDown", "s", "S"].includes(e.key)) moveDir.down = 0;
      });

      // 触屏虚拟摇杆
      let joyActive = false,
        joyStart = { x: 0, y: 0 },
        joyCenter = { x: 0, y: 0 },
        joyRadius = 0;
      // 初始化摇杆中心和半径
      function updateJoystickCenter() {
        const rect = joystick.getBoundingClientRect();
        joyCenter.x = rect.left + rect.width / 2;
        joyCenter.y = rect.top + rect.height / 2;
        joyRadius = rect.width / 2;
      }
      window.addEventListener("resize", updateJoystickCenter);
      setTimeout(updateJoystickCenter, 300); // 初始加载
      joystick.addEventListener("touchstart", (e) => {
        updateJoystickCenter();
        joyActive = true;
        let t = e.touches[0];
        // stick回到中心
        stick.style.left = "28%";
        stick.style.top = "28%";
        moveDir.left = moveDir.right = moveDir.up = moveDir.down = 0;
        moveDir._amp = 0;
        moveDir._vx = 0;
        moveDir._vy = 0;
      });
      joystick.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault(); // 阻止默认滚动
          if (!joyActive) return;
          let t = e.touches[0];
          let dx = t.clientX - joyCenter.x,
            dy = t.clientY - joyCenter.y;
          let len = Math.sqrt(dx * dx + dy * dy);
          let maxLen = joyRadius * 0.72; // stick活动范围，不能超出底座圆
          if (len > maxLen) {
            dx = (dx * maxLen) / len;
            dy = (dy * maxLen) / len;
            len = maxLen;
          }
          // stick位置（百分比，居中）
          let px = 28 + (dx / joyRadius) * 28;
          let py = 28 + (dy / joyRadius) * 28;
          stick.style.left = px + "%";
          stick.style.top = py + "%";
          // 方向
          let vx = dx / maxLen;
          let vy = dy / maxLen;
          let threshold = 0.12; // 死区
          moveDir.left = moveDir.right = moveDir.up = moveDir.down = 0;
          let amp = len / maxLen;
          if (amp > threshold) {
            // 方向分量
            moveDir._vx = vx;
            moveDir._vy = vy;
            moveDir._amp = amp;
          } else {
            moveDir._vx = 0;
            moveDir._vy = 0;
            moveDir._amp = 0;
          }
        },
        { passive: false }
      );
      joystick.addEventListener("touchend", (e) => {
        joyActive = false;
        stick.style.left = "28%";
        stick.style.top = "28%";
        moveDir.left = moveDir.right = moveDir.up = moveDir.down = 0;
        moveDir._amp = 0;
        moveDir._vx = 0;
        moveDir._vy = 0;
      });

      // 按钮重开
      restartBtn.addEventListener("click", resetGame);
    </script>
  </body>
</html>
